------------------------------------------------------------------------------------------------------------------------
Selenium cant handle Desktop application.open source for web application

Appium-->mobile application testing

Desktop application-->
Robot Framework-->
WinAppDriver-->
katalon-->

Headless browser-->perform same functionality as standard browser but without GUI.

Window based popup-->selenium cant handle window base popup because its web base automation tool.
Third party tool like "AutoIT" or "Robot class"

proxy in selenium--> a proxy server can be used to route traffic through middle layer testing purposes.
you can configure proxies using DesiredCapabilites.

DesiredCapabilities -->set browser properties with browser,version, platform before starting webdriver session.

HTTPS cerification issue-->
selenium can handles these issue using browser-specific setting or DesiredCapabilities.

SelectorHub-->selectorhub debugger feature use to freeze the hidden /disappearing element.

Selenium 4.27 update -->
getAttribute depreciated -->
cause-->user wrongly use getAttribute method find visibleText that negatively impacted
solution--> driver.getDomAttribute('attr name');

---------------------------------------------------------------------------------------------------------
Selenium Webdriver-->Selenium WebDriver is a code library of APIs for controlling browsers.
Selenium Grid--> Selenium Grid is a smart proxy server that makes it easy to run tests in parallel on multiple machines
Selnoid-->Selenoid is an open-source, automated testing solution that runs browsers in Docker containers
selense-->scripting language-used for writing selenium command
Selenium IDE-->open source having record and playback feature

                ###Limitation of selenium ###
1.cant handle desktop application
2.no reporting facilities-should add third party dependencies
3.Handling captcha and barcode
4.requires the external tool for mobile testing -appium
------------------------------------------------------------------------------------------------
                    ### handling Captcha ###

 for handling captcha -third party tool like "OCR" or APIs.
 use services like "2Captcha" to solve captchas programmetically.
 "2captcha"--> provides bypass for selenium

 -----------------------------------------------------------------------------------------
            ### Advantage of Selenium ###

1.mulitple lagnuage support
2.open source tool
3.cross-platform
4.large community support

-----------------------------------------------------------------------------------------------------------
                    ### absolute xpath and Relative xpath ###

1.absolute xpath--> starts of root of HTML document to desired element
2.Relative xpath--> middle of dom element to desired element
------------------------------------------------------------------------------------------------------------
Difference verify and Assert?

verify(soft assertion)-->If the verify condition fails, the test continues to run until the last test is executed.
Assert(hard assertion)-->If the assert condition fails, the test case is marked as failed,
and the remaining tests are skipped
----------------------------------------------------------------------------------------------------------
                        ### WebDriver Methods ### WebDriver is Interface

1.close()-->current open window
2.quit()-->all opened windows
3.getCurrentUrl()-->url of current webpage
4.getPageSource()-->get source of loaded page
5.get()-->load new webpage in current window
6.getTitle()-->title of current webpage
7.switch()-->
8>navigate()-->
9.manage()-->
10.setPosition()-->set the window position
11.getPosition()-->get the window position
12.setSize()--> set width and height of webelement
13.getSize()-->get width and height of webelement
14.clear()-->clear context of textbox
15.getText()-->It will return visible text

driver.get()-->wait for load the complete page
driver.navigate().to()-->doesn't wait for full page load

Maximum screen size-->
driver.manage().window().maximize();

isEnabled()-->checked if element is enabled for interaction
isDisplayed()-->check if element is visible on the page
isSelected()-->check if checkbox or radio button is selected
----------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------
                        ### Locators ###
locator-->A locator is a way to identify elements on a page

1.id               --> driver.findElement(By.id("Lname"));
2.name              -->driver.findElement(By.name("newsletter"));
3.linkText          -->driver.findElement(By.linkText("Selenium Official Page"));
4.partialLinkText   -->driver.findElement(By.partialLinkText("Official Page"));
5.tagName           -->driver.findElement(By.tagName("a"));
6.className        -->driver.findElement(By.className("information"));
7.cssSelector      -->driver.findElement(By.cssSelector("#fname"));
8.xpath             -->driver.findElement(By.xpath("//input[@value='f']"));

## Relative locator-->introduced in Selenium 4
1.Above     -->If the email text field element is not easily identifiable for some reason, but the password text field element is,
we can locate the text field element using the fact that it is an “input” element “above” the password element.

                By emailLocator = RelativeLocator.with(By.tagName("input")).above(By.id("password"));

2.Below     -->If the password text field element is not easily identifiable for some reason, but the email text field element is,
 we can locate the text field element using the fact that it is an “input” element “below” the email element.

                By passwordLocator = RelativeLocator.with(By.tagName("input")).below(By.id("email"));

3.Leftof-->
                By cancelLocator = RelativeLocator.with(By.tagName("button")).toLeftOf(By.id("submit"));

4.RightOf-->
                By submitLocator = RelativeLocator.with(By.tagName("button")).toRightOf(By.id("cancel"));

5.Near-->
                By emailLocator = RelativeLocator.with(By.tagName("input")).near(By.id("lbl-email"));

6.chaining of Relative locators-->
                By submitLocator = RelativeLocator.with(By.tagName("button")).below(By.id("email")).toRightOf(By.id("cancel"));
----------------------------------------------------------------------------------------------------------------
                    ### Xpath ###

1.xpath by id--> driver.findElement(By.xpath("//*[@id="inputid"));
2.xpath by className-->driver.findElement(By.xpath("//*[@class="classname"));
3.xpath by name--> driver.findElement(By.xpath("//*[@name="name"));
4.xpath by text--> driver.findElement(By.xpath("//*[text()='Ronit']"));
5.xpath by contains-->driver.findElement(By.xpath("//*[contains(@href,'google.com')]"));
6.xpath by start-with-->driver.findElement(By.xpath("//*[starts-with(@id,'user')]"));
7.xpath by end-with-->driver.findElement(By.xpath("//*[ends-with(@id,'name')]"));

Axes-->
1.driver.findElement(By.xpath("//div[@id='main-section']/following::div"));
driver.findElement("//input[@id='username']/ancestor::form");
driver.findElement("//input[@id='username']/ancestor::form[1]")
//div[@id='content']/child::p`.
//tag[@attribute='value']/parent::tagName`
------------------------------------------------------------------------------------------------
                    ### cssSelector ###

CSSSelectors in Selenium are used to identify and locate web elements based on their id, class, name, attributes and other attributes.
CSS is a preferred locator strategy as it is simpler to write and faster as compared to XPath.

===> preferred use this way-->
driver.findElement(By.cssSelector("a[class='login']"));

1.ID--> " * "-->notation used to select id
     ex.   driver.findElement(By.cssSelector("a[id='offer']"));
           driver.findElement(By.cssSelector("#offer"));
           driver.findElement(By.cssSelector("a#offer"));

2.class--> " . " notation used to select class
        ex.  driver.findElement(By.cssSelector("a[class='Navbar_logo__26S5Y']");
             driver.findElement(By.cssSelector("a.Navbar_logo__26S5Y"));
             driver.findElement(By.cssSelector(".Navbar_logo__26S5Y"));

3.Attribute-->
            ex. driver.findElement(By.cssSelector("a[href='/favourites']");

4.sub-string--> allows to match partial string
            1.start-With--> " ^ " notation use for start-with
            driver.findElement(By.cssSelector("a[class^='navbar_log']"));

            2.end-with-->" $ " notation use for end-with
            driver.findElement(By.cssSelector("a[class$='2689Y']");


            3.contains-->" * "--> notation use for contains
            ex. driver.findElement(By.cssSelector("a[class*='logo_']");


-----------------------------------------------------------------------------------------------------------
                        ### Handling cookies ###

A cookie is a small piece of data that is sent from a website and stored in your computer.
Cookies are mostly used to recognise the user and load the stored information.

1.GetCookies-->
        driver.manage().getCookies();
        driver.manage().getCookieNamed(arg o);

2.addCookie-->
    driver.manage().addCookie(arg o);
    driver.manage().addAllCookies();

3.DeleteCookies-->
     driver.manage().deleteCookie(arg o);
     driver.manage().deleteAllCookies();

----------------------------------------------------------------------------------------------------
                    ### Delete the Cache ###

public void ClearBrowserCache()
{
webDriver.Manage().Cookies.DeleteAllCookies(); //delete all cookies
}

----------------------------------------------------------------------------------------------------------
               ### Shadow DOM ###-->"getShadowRoot() " method

The Shadow DOM is a way to achieve encapsulation in the HTML document.

-"NoSuchElementException" directly when we try accessible to shadow dom element

$ solution-->
1.getShadowMethod()-->selenium method
-->WebElement shadowHost = driver.findElement(By.cssSelector("#shadow_host"));
   SearchContext shadowRoot = shadowHost.getShadowRoot();
   WebElement shadowContent = shadowRoot.findElement(By.cssSelector("#shadow_content"));

2.JavaScriptExector-->

----------------------------------------------------------------------------------------------------------
                ## Selenium Exception ###

 Difference between Invalid Session or NoSession Exception-->

 0.NoSuchSessionException:-->when browser session is no longer active

1.InvalidSessionIDException:-->server does not recognize session identifier and
associated user token is no longer authorized or authneticated on platform.

 2.NoAlertPresentException-->Raised when an expected alert is not present. Happens when trying to interact
 with an alert that doesn’t exist.
 solution-->use try-catch block4.

 3.ElementClickInterceptedException-->raised when an element you try to click is not clickable because another element is blocking it.
solution-->use javaSriptExecutor

4.StaleElementReferenceException--> element is no longer attached to the actual DOM of the web page


            ### NoSuchElementException vs StaleElementReferenceExcpetion ###
 5.NoSuchElementException-->Element doesnt exist on webpage
 6.ELementNotVisibleException-->ELment exist but its hidden
 -----------------------------------------------------------------------------------------------------------------------
                    ### Handling or solution for selenium Exception ###

  try{

  }
  catch(Exception e){

  System.out.println(e.getMessage());
  }



 1.StaleElementReferenceExcpetion-->Refresh the locators or add wait conditions.
 2.ElementNotInteractableException---->occur when interact with hidden or unclikable elements.
                    use javascriptExceutor instead of click
           js.executeScript("arguments[0].click();",element);
-----------------------------------------------------------------------------------------------
                  ### connect DATABASE (JDBC)###

    JDBC-->Java Database connectivity

String userid="userid;
String password="password";
String url="https:url"

//establish a connection
Connection connection=DriverManager.getConnection(url,userid,password);

//create statement
        Statement stat=conn.createStatement();

  ResultSet rs=stat.executeQuery("SELECT * from user");

-----------------------------------------------------------------------------------------------------
                   ### waits #####

 WebDriverWait in selenium-->explicit wait

 which is best wait to apply in selenium-->explicit wait

 Thread.sleep-->Thread.sleep(2000)-->static wait provided by java
 Thread.sleep throw a "InterruptedException".

 implicit wait-->driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
 WebDriver to wait for a specified amount of time when trying to locate an element before throwing a NoSuchElementException.


Explicit wait--> wait for a specific condition to be true before proceeding further.
It allows you to wait for a particular element or condition with a specific timeout.

 Explicit wait-->WebDriverWait wait = new WebDriverWait(driver,30);
                 wait.until(ExpectedConditions.visibilityOfElementLocated(WebElement));

 Fluent wait-->Fluent wait looking element the wait conditions, such as checking for the condition at regular intervals
 and ignoring certain exceptions

 FluentWait wait = new FluentWait(driver);
 wait.withTimeout(5000, TimeUnit.MILLISECONDS).pollingEvery(250, TimeUnit.MILLISECONDS).ignoring(NoSuchElementException.class)
.until(ExpectedConditions.alertIsPresent());

-------------------------------------------------------------------------------------------------------------------------
            ## JavaScriptExceutor ###

 # JavascriptExecutor is interface and its perform operation on webpage like scrolling,inner text,title etc

# JavaScriptExcecutor is used for finding "hidden element in DOM".

 JavaScriptExecutor is an interface that is used to executeJavaScript through selenium webdriver. JavaScript is a programming language
  that interacts with HTML in a browser, and to use this function in Selenium, JavascriptExecutor is required.

  JavascriptExecutor js = (JavascriptExecutor) driver;
  scroll by-->  js.executeScript(“window.scrollBy(0,150)”);
  get title--> string sText =  js.executeScript(“return document.title;”).toString();
  inner text of webpage-->string sText =  js.executeScript(“return document.documentElement.innerText;”).toString();
  alert poput window--> Js.executeScript(“alert(‘hello world’);”);

## Window Resize-->
window.resizeTo() method and capability commands can also be used to achieve the same result.
  Use windows.resizeTo() method along with Javascript executor.
                    JavascriptExecutor js=(JavascriptExecutor)driver;
                js.executeScript("window.resizeTo(600,400);");

  ----------------------------------------------------------------------------------------------------------------------
                    findElement() and findElements()?

  findElement()-->method which finding out webElement on webpage and return noELmentfoundExption for no webelement.
  findElements()-->method which finding out mutliple elements on webpage and return zero element for no webelment.
  ---------------------------------------------------------------------------------------------------------------------------
               Diff between getWindowHandle and getWindowHandles ?

  It is a unique identifier that holds the address of all the windows. Think of it as a pointer to a window, which returns the string value.
  It is assumed that each browser will have a unique window handle.

  getWindowHandle-->This method helps to get the window handle of the current window
                    String parentWindow=driver.getWindowHandle();

  getWindowHandles-->This method helps to get the handles of all the windows opened
                    String <set> allwindows=driver.getWindowHandles();

Widows popup handled by-->getWindowHandle

  switch to: This method helps to switch between the windows
  action: This method helps to perform certain actions on the windows
  ---------------------------------------------------------------------------------------------------------
                    ### How to close second open window ###

      //start browser & open url
                    driver.get(url);

//get all window handles
   Set<String>handles=driver.getWindowHandles();

   //switch to second window
   driver.switchTo().window(handles[i]);

   //close the second window
   driver.close();

   //switch back to original window
   driver.switchTo().window(handles[o]);
   driver.quit();


  ---------------------------------------------------------------------------------------------------
                    ### Action class ###

  Action-->Interface
  Actions-->class

  Actions class is an ability provided by Selenium for handling keyboard and mouse events

  Actions action=new Actions(driver);
  action.moveToElement(element).build().perform();
  click()-->    action.click(element).build().perform();


  Mouse Actions in Selenium:

  doubleClick(): Performs double click on the element
  action.doubleClick(element).perform();

  clickAndHold(): Performs long click on the mouse without releasing it
  action.clickAndHold(element).perform();

  dragAndDrop(): Drags the element from one point and drops to another
  action.dragAndDrop(sourcelocator,destinationlocator).build().perform();

  moveToElement(): Shifts the mouse pointer to the center of the element

  contextClick(): Performs right-click on the mouse
  action.contextClick(element).build().perform();

  sendKey()--
  WebElement searchbox=driver.findElmenet(xpath);
  action.sendkey(searchbox,"selenium").perform();

  --------------#####------####-------####---------#####----------####-------####-----####----
  Keyboard events:

   Actions action=new Actions(driver);
  1.TAB-->
  action.sendKeys(keys.TAB);

  2.control+All
  // Select the Current Address using CTRL + A
          actions.keyDown(Keys.CONTROL);
          actions.sendKeys("a");

 --------------------------------------------------------------------------------------------------------
                ### PageFactory ###

PageFactory-->
1.Finding web elements using @FindBy
2.PageFactory is a class that implements the Page Object Model design pattern.

Page Factory is a class provided by Selenium WebDriver to support Page Object Design patterns. In Page Factory, testers use @FindBy annotation.
The initElements method is used to initialize web elements.

public BrowserStackHomePage(WebDriver driver) {
this.driver = driver;
PageFactory.initElements(driver, this);
}

PageObject Model-->(object repository)
1.finding webElements of page using "By"class
2.Page Object Model is a design pattern
Page Object Model, also known as POM, is a design pattern in Selenium that creates an object repository for storing all web elements.
It helps reduce code duplication and improves test case maintenance.
POM assign seperate page class for each webpage

-------------------------------------------------------------------------------------------------------
                ### Screenshot ###

 Screenshots also help you when your test case fails so that you can identify what went wrong in your script or your application.
1.we convert webdriver to TakeScreenShot and call getScreenshotAs() method to create an image file by providing the parameter *OutputType.FILE
    //Convert webdriver to TakeScreenshot
    File source = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        File Destination="filepath.jpg";
2. we can use this File object to copy the image at our desired location, as shown below, using the FileHandler class
   FileHandler.copy(source,Destination);
 --------------------------------------------------------------------------------------------------------------------
            ### Full Screenshot ###-->" Ashot "

  selenium doesn't have capabilites to take full page screeshot. we have to use a third-party library named "Ashot".
---------------------------------------------------------------------------------------------------------
  Desired Capabilities-->

  In Selenium 3, capabilities were defined in a session by using Desired Capabilities classes.
  As of Selenium 4, you must use the browser options classes. For remote driver sessions, a browser options instance is required as it determines which browser will be used.
ChromeOptions chromeOptions = new ChromeOptions();
	String version = "latest";
	chromeOptions.setBrowserVersion(version);


  DesiredCapabilities are a set of key-value pairs encoded as a JSON object.It helps QAs define basic test requirements such as operating systems,
  browser combinations, browser versions, etc. within Selenium test scripts.

  1. getCapability()-->This method helps in retrieving the capabilities of the current system on which the tests are being performed.
  2. getBrowserName()-->method helps in retrieving the browser name of the current system.
                    public java.lang.String getBrowserName()
  3.setBrowserName();
    This method is used to set the name of the browser on which tests are to be executed.

    public void setBrowserName(java.lang.String browserName)

    public static void main(String[] args) throws Exception {
        DesiredCapabilities caps = new DesiredCapabilities();
        caps.setCapability("browser", "Chrome");
        caps.setCapability("browser_version", "128.0");
        caps.setCapability("os", "Windows");
        caps.setCapability("os_version", "11");
-----------------------------------------------------------------------------------------------------------------------------------
                        ### Alert ###

Alert in Selenium is a message/notification box that notifies the user about some information or asks for permission to perform a certain kind of operation.
It may be used for warning purposes as well.

1.simple alert-->notify the warning message with "ok" button.
2.prompt alert-->alert ask the input to complete the task from user.
3.confirmation alert-->alert ask confirmation of input like yes or no.

1. cancel button--> driver.switchTo().alert().dismiss();
2.accept button--> driver.switchTo().alert().accept();
3.getText(capture alert message)--> driver.switchTo().alert().getText();
4.sendKeys(send data to alert box)-->driver.switchTo().alert().sendKeys("Ronit");
-------------------------------------------------------------------------------------------------------------
                    ### OOPS concept used in selenium project ###

 WebElement-->interface
 WebDriver-->Interface
 FindBy-->annotation
 FindElement-->"method" in pom to identify webelement

 constructor-->intilize webdriver instance,manage configuration or set up intial state for test classes or utilty.

 1.Inheritance--> one class acquires the property of another class.
 We create a Base Class in the Automation Framework to initialize the WebDriver interface, WebDriver waits, Property files, Excels, etc., in the Base Class.
 We extend the Base Class to other classes such as Tests and Utility Class.

 2.Polymorphism-->
 2.1 Method overloading-->"implicit wait"-use different timestamp like sec,min and hrs.
                    Action class and Assert class also example of method overloading

 2.2 Method overrriding-->We use a method which was already implemented in another class by changing its parameters.
                    "get" and "navigate" methods of different drivers in Selenium .

3.Abstraction(POM-locators)--> Page Object Model design pattern, we write locators (such as id, name, xpath etc.,) and the methods in a Page Class.
We utilize these locators in tests but we can’t see the implementation of the methods.
 Literally we hide the implementations of the locators from the tests.

4.Interface-->WebDriver driver = new FirefoxDriver();

5.Encapsulation-->ll the classes in a framework are an example of Encapsulation.
In POM classes, we declare the data members using @FindBy and initialization of data members will be done using Constructor to utilize those in methods.
----------------------------------------------------------------------------------------------------------------
                       ### DropDown ###

 Select:-->Select class provides the implementation of the HTML SELECT tag. A Select tag provides the helper methods with select and deselect options
            Select select = new Select();
            WebElement list=driver.findElement(By.id("Xpath"));


  selectByVisibileText(String arg)-->
            select.selectByVisibleText("text");

  selectByIndex(int)-->
            select.selectByIndex();

  getOptions()-->List<WebElement>
            List <WebElement> list=select.getOptions();
            System.out.println(list.size());

selectByValue(String arg)-->
         select.selectByValue("text");

  deselectAll()-->select.deselectAll();

  isMultiple()-->
  boolean – This method informs whether the Select element supports multiple selection options at the same time or not.
  This method accepts nothing and returns a boolean value (true/false).
        select.isMultiple();

---------------------------------------------------------------------------------------------------------------------------
                        ### Navigation command ###

1.driver. navigate().to("url") --> command allows the user to launch a new web browser window
2.driver.navigate().refresh()-->refresh current webpage
3.driver.navigate().back()-->come to previous webpage
4.driver.navigate().forward()-->move to the next webpage

Difference betn navigate().refresh() & driver.get(driver.getCurrentUrl())?
1.navigate().refresh()-->refreshes the browser window
2.driver.get(driver.getCurrentUrl())-->load the current url again which also result page refresh
----------------------------------------------------------------------------------------------------------
                   ## Data Driven (data extract from excel file)###

//file class for open xlsx file
  File file=new File(excelfilepath);

//create object of fileInputstream  class to read excel sheet
FileInputStream inputstream=new FileInputStream(file);


//creating workbook instance that refers to .xls file
workbook=new HSSFWorkbook(inputStream);

//creating a Sheet object
sheet=workbook.getSheet(sheetName);

public String getCellData(int rowNumber,int cellNumber){
       //getting the cell value from rowNumber and cell Number
        cell =sheet.getRow(rowNumber).getCell(cellNumber);

        //returning the cell value as string
        return cell.getStringCellValue();
    }
---------------------------------------------------------------------------------------------------------
                        ### iframe ###

  iframe depreciated on in HTML 5 but before HTML 5 using iframe using Iframes allow the insertion of a document
   from an entirely different domain,
Selenium is only aware of the elements in the top level document. To interact with the button,
we will need to first switch to the frame,
   in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.

   1.using WebElement-->
   WebElement frameelement=driver.findElmement("xpath");
    driver.switchTo().frame("frameelement");

   2.using name or id-->    driver.switchTo().frame("frameresult");
   3.using index-->         driver.switchTo().frame(index);

##.switching back to main page-->
driver.switchTo().defaultContent();

---------------------------------------------------------------------------------------------------------
                        ###broken links ###

Broken link-->A broken link, also often called a dead link, is one that does not work i.e. does not redirect to the webpage.
1.Use <a> tag to fetch all the links present on a web page
2.Send HTTP request for the link
3.Verify the HTTP response code for the link
4.Determine if the link is valid or it is broken based on the HTTP response code
5.Repeat the process for all links captured with the first step

 1.   List <WebElement> links=driver.findElement(By.tagName("a");

    //iterate into each link to validate the status code
    for(WebElement link:links){
    String url=driver.getDOMAttribute("href");


    URL link=new URL(url);

 2  HttpURLConnection httpURLConnection = (HttpURLConnection) link.openConnection();
   httpURLConnection.setConnectTimeout(3000); // Set connection timeout to 3 seconds
   httpURLConnection.connect();
 3 if (httpURLConnection.getResponseCode() == 200) {
   System.out.println(url + " - " + httpURLConnection.getResponseMessage());
   } else {
   System.out.println(url + " - " + httpURLConnection.getResponseMessage() + " - " + "is a broken link");
   }
   } catch (Exception e) {
   System.out.println(url + " - " + "is a broken link");
   }
    }

---------------------------------------------------------------------------------------------------------
                        ### WebTable ###

 <table>    -->table
 <th>  -->header
 <tr>   -->row
 <td> -->coloumn

 1. webtable-->table having data -row and coloumn in html code
 2.static table--> table data remains unchanged
 3.dynamic table-->table data changes eventually

 How to handle the dynamic webtable?
 1.finding the xpath of selected element
 2.finding the number of row and coloumn of table
 3.finding cellvalue of particular row and coloumn

--------------------------------------------------------------------------------------------------------

              ### IMP Questions ###

 1.Window resize-->can we minimize and maximize the window size?
                int width = 600;
                int height = 400;
                Dimension dimension = new Dimension(width, height);
                driver.manage().window().setSize(dimension);




  2. How to Handle colors in webdriver?
        "getCSSValue(arg0)"" to fetch the colours by sending the colour as the argument

  3.How to debug the test in Selenium?
  -->using "breakpoints"

  4.typeAndWait-->"typeAndWait" command is used when you finish typing and the software web page begins to reload.

  5.upload files-->element.sendKeys(filepath)-we need to use the HTML tag ‘input’ with the attribute type as a file

   6.how do yo handle dynamic webelemtns in selenium? -->
        fluent wait and explicit wait..cssSelector& xpaths
        use selectorHub -debugger (freeze)


   7.How do you handle situation where an element is not visible(hidden element)?
            Hidden elements are the ones that are present in the DOM but not visible on the web page.
            hidden elements are defined by the CSS property style="display:none;"

            "JavascriptExecutor"-->
             // Javascript executor class with executeScript method
                  JavascriptExecutor js = (JavascriptExecutor) driver;
                   js.executeScript
                        ("document.getElementById('displayed-text').value='Selenium';");

    8. When do you use Xpath over CSS locators?
    9.What happens if you receive browser notifications in between Test Automation Execution?
    10.
----------------------------------------------------------------------------------------------------------

                    ### File uploads ###-->sendKeys() or AUTOIT tool

 Selenium cant interact with file uploads but if the element is an "input" element with type "file"
 then you can use sendkeys method to send full path to file upload

 WebElement fileupload=driver.findElement(By.xpath(""));
 fileupload.sendKeys("filepath");

 ----------------------------------------------------------------------------------------------------------
                ### File Download ###

   handling file downloads by setting browser preferences.

   for(chrome)-->

   ChromeOptions options=new ChromeOptions();
   options.addArguments("download.default_directory=C:\\Downloads");
   WebDriver driver=new ChromeDriver(options);

   -----------------------------------------------------------------------------------------------

                ### Logging(Log4J) in Selenium ###

    1.add Log4J dependencies in project
    use logging implementation for better traceability .

    Logger logger=Logger.getLogger("testlog");
    logger.info("Test started");
    -------------------------------------------------------------------------------------------------
                ### Email Testing ###-->JavaMail API

   Use "JavaMail API" to fetch email and validate email contents
   -----------------------------------------------------------------------------------------------------
                        ### Tooltip ###--> "getAttribute()" method

   tooltip-->small hoverable elements that provide additional information when a user hovers over an element on a webpage.

        WebElement element=driver.findElement(By.id("tooltip"));
        String tooltip=element.getAttribute("title");
        System.out.println("Tooltips"+tooltip);

   ---------------------------------------------------------------------------------------------------------
                ### Session Management ###-->"getSessionId()" method

   manages browser sessions using cookies or webdriver capabilities
        //remotewebdriver convert into webdriver

   String sessionid=((RemoteWebDriver)driver).getSessionId().toString();
   System.out.println("Session id "+sessionid);

   ----------------------------------------------------------------------------------------------
                    ### handle Browser notification ###

    browser notification / push notification handle-->
    we have to use ChromeOptions to disable push notification.

    ChromeOptions option=new ChromeOptions();
    option.addArguments("--disable-notifications");
    -------------------------------------------------------------------------------------------






